En esta unidad siento que aprendí bastante, especialmente en todo lo relacionado con la implementación de máquinas de estados y cómo manejar eventos desde distintas fuentes, como el micro:bit y p5.js. Al principio no entendía muy bien cómo separar los eventos del funcionamiento interno de la bomba, pero con los ejercicios logré ver lo útil que es separar las tareas como `tareaEventos()` y `tareaBomba()`. Me ayudó mucho a entender que un evento puede venir de cualquier parte, y no importa de dónde venga mientras se gestione bien.
También aprendí bastante sobre cómo trabajar con concurrencia de forma ordenada. Antes simplemente hacía que todo funcionara al mismo tiempo sin pensar en las consecuencias, pero ahora comprendo que dividir tareas y controlar los eventos hace que el sistema sea más estable y escalable. Un ejemplo claro fue cuando logré que los eventos tanto del botón del micro:bit como del sketch en p5.js controlaran la misma bomba sin generar conflictos. Eso me pareció brutal porque nunca había hecho algo tan conectado antes.
Otro concepto que me quedó claro fue el de pruebas. En serio, nunca me había puesto a pensar en los vectores de prueba. Yo antes probaba el código al ojo, y si funcionaba, pues todo bien. Pero ahora entendí que hacer pruebas específicas para cada estado y evento es clave para saber si el sistema está sólido. También aprendí la importancia de las pruebas de regresión, porque a veces uno arregla una cosa y sin querer daña otra, y esas pruebas sirven justo para eso.
Lo que todavía me cuesta un poco es el tema de optimización del código. Muchas veces siento que mi código funciona, pero está largo o repetido, y aunque trato de usar funciones para organizarlo, aún me falta encontrar la forma más elegante de escribirlo. También me cuesta a veces interpretar bien los errores del micro:bit, especialmente cuando algo no se conecta bien o los eventos no llegan como deberían. A veces me frustro porque el código se ve bien pero no responde, y me demoro bastante en encontrar el error.
